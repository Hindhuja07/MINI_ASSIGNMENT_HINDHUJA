For this project, I built a small full-stack web application that allows users to create, store, and search their personal notes using simple AI-based semantic matching. I used FastAPI for the backend because it provides a clean structure, automatic documentation, and asynchronous request handling, which makes building REST APIs efficient and easy to maintain. The backend includes three main endpoints: one for creating a note, one for listing all notes, and one for performing semantic searches. Each endpoint returns JSON responses and uses Pydantic models for validation to ensure data consistency.

For the database, I chose SQLite because it is lightweight, file-based, and perfect for small projects that don’t require an external database setup. I used SQLModel, which combines the benefits of SQLAlchemy and Pydantic, allowing me to define database models with type hints. The database has a single notes table with four fields — id, title, content, and embedding. The embedding column stores a numerical vector in JSON format, which represents the meaning of the note. I stored embeddings as JSON strings since SQLite does not have a built-in vector type. For larger-scale systems, this can later be replaced with FAISS or PostgreSQL with pgvector for faster similarity searches.

For the AI component, I integrated the sentence-transformers/all-MiniLM-L6-v2 model to generate text embeddings. Whenever a note is created, the title and content are combined and passed through this model to generate an embedding — essentially a numerical representation of the note’s meaning. During a search, the user’s query is embedded using the same model, and then cosine similarity is computed between the query vector and each note vector in the database. The notes with the highest similarity scores are returned as search results. This approach allows the system to understand semantic relationships between notes, rather than relying on exact keyword matches.

The frontend is built using React.js, designed to be minimal yet functional. It includes a form for adding new notes, a search bar for querying existing notes, and a section to display all notes or search results. I used basic React Hooks such as useState and useEffect for state management and handled API communication using the Fetch API or Axios. The focus was on simplicity and responsiveness rather than complex styling or frameworks.

In terms of trade-offs, I prioritized simplicity and clarity over scalability. Storing embeddings as JSON makes it easy to prototype, but it is not optimal for large datasets or fast similarity searches. The current implementation performs a linear cosine similarity scan, which works fine for small data but would need optimization for larger use cases. Authentication and user management were intentionally skipped to keep the focus on the main functionality. If I continue this project, I would add user login with JWT tokens, tagging or categorization for notes, and possibly clustering to group similar notes automatically.

Overall, this project demonstrates my understanding of backend API design, database schema planning, AI integration through embeddings, and frontend-backend communication. My goal was to build a clean, working system that connects all these parts logically while keeping the implementation straightforward and educational.